package adder

import (
	"strings"
	"text/template"
)

// Templates contains all code generation templates
var Templates = struct {
	Command string
	Package string
}{
	Command: commandTemplate,
	Package: packageTemplate,
}

const packageTemplate = `// Code generated by adder. DO NOT EDIT.

package {{.Package}}

import (
	{{- if .NeedsFmt}}
	"fmt"
	{{- end}}
	{{- if .NeedsIO}}
	"fmt"
	"io"
	"os"
	{{- end}}
	
	"github.com/spf13/cobra"
)

{{- if .NeedsIO}}

// ReadFromArgsOrPipe reads data from file argument or stdin pipe
func ReadFromArgsOrPipe(args []string, pipe *os.File) []byte {
	if len(args) > 0 {
		return ReadFromFile(args[0])
	} else {
		if pipe == nil {
			pipe = os.Stdin
		}
		return ReadFromPipe(pipe)
	}
}

// ReadFromPipe reads data from a pipe, returns nil if no piped data
func ReadFromPipe(in *os.File) []byte {
	stat, err := in.Stat()
	if err != nil {
		panic(fmt.Sprintf("failed to read stat from stdin: %v", err))
	}
	if (stat.Mode() & os.ModeCharDevice) == 0 {
		buf, err := io.ReadAll(in)
		if err != nil {
			panic(fmt.Sprintf("failed to scan bytes from stdin: %v", err))
		}
		return buf
	}
	return nil
}

// ReadFromFile reads data from a file path
func ReadFromFile(filePath string) []byte {
	file, err := os.Open(filePath)
	if err != nil {
		panic(fmt.Sprintf("failed to open file at path: %s: %v", filePath, err))
	}
	defer file.Close()

	bytes, err := io.ReadAll(file)
	if err != nil {
		panic(fmt.Sprintf("failed to read bytes from file at path: %s: %v", filePath, err))
	}
	return bytes
}

{{- end}}
`

const commandTemplate = `
{{- $cmd := .Command }}
{{- $structName := .StructName }}
{{- $handlerName := .HandlerName }}
{{- $methodName := .MethodName }}
{{- $functionName := .FunctionName }}

{{- if $cmd.Arguments}}
// {{$structName}}Arguments represents the arguments for the {{$cmd.Name}} command
type {{$structName}}Arguments struct {
	{{- range $cmd.Arguments}}
	{{pascalCase .Name}} {{.Type}} ` + "`" + `json:"{{camelCase .Name}}"{{if .Required}} validate:"required"{{end}}` + "`" + `{{if .Description}} // {{escapeString .Description}}{{end}}
	{{- end}}
}
{{- end}}

{{- if $cmd.Flags}}
// {{$structName}}Flags represents the flags for the {{$cmd.Name}} command
type {{$structName}}Flags struct {
	{{- range $cmd.Flags}}
	{{pascalCase .Name}} {{.Type}} ` + "`" + `json:"{{camelCase .Name}}"{{if .Enum}} validate:"oneof={{range $i, $v := .Enum}}{{if $i}} {{end}}{{$v}}{{end}}"{{end}}` + "`" + `{{if .Description}} // {{escapeString .Description}}{{end}}
	{{- end}}
}
{{- end}}

{{- if $cmd.PersistentFlags}}
// {{$structName}}PersistentFlags represents the persistent flags for the {{$cmd.Name}} command
type {{$structName}}PersistentFlags struct {
	{{- range $cmd.PersistentFlags}}
	{{pascalCase .Name}} {{.Type}} ` + "`" + `json:"{{camelCase .Name}}"{{if .Enum}} validate:"oneof={{range $i, $v := .Enum}}{{if $i}} {{end}}{{$v}}{{end}}"{{end}}` + "`" + `{{if .Description}} // {{escapeString .Description}}{{end}}
	{{- end}}
}
{{- end}}

// {{$structName}} represents the parameters for the {{$cmd.Name}} command
type {{$structName}} struct {
	{{- if $cmd.Arguments}}
	Arguments {{$structName}}Arguments ` + "`" + `json:"arguments"` + "`" + `
	{{- end}}
	{{- if $cmd.Flags}}
	Flags {{$structName}}Flags ` + "`" + `json:"flags"` + "`" + `
	{{- end}}
	{{- if $cmd.PersistentFlags}}
	PersistentFlags {{$structName}}PersistentFlags ` + "`" + `json:"persistent_flags"` + "`" + `
	{{- end}}
	RawArguments []string ` + "`" + `json:"raw_arguments"` + "`" + ` // Raw command line arguments passed to the command
}

// {{$handlerName}} defines the function type for handling {{$cmd.Name}} commands
type {{$handlerName}} func(cmd *cobra.Command, req *{{$structName}}) error

// {{$functionName}} creates a new {{$cmd.Name}} command with the provided handler function
func {{$functionName}}(handler {{$handlerName}}) *cobra.Command {
	cmd := &cobra.Command{
		Use:     "{{cleanCommandName $cmd.Name}}{{range $cmd.Arguments}} [{{.Name}}]{{end}}",
		{{- if $cmd.Aliases}}
		Aliases: []string{{"{"}}{{range $i, $alias := $cmd.Aliases}}{{if $i}}, {{end}}"{{$alias}}"{{end}}{{"}"}},
		{{- end}}
		Short:   "{{$cmd.Title}}",
		{{- if $cmd.Arguments}}
		Args: cobra.ExactArgs({{len $cmd.Arguments}}),
		{{- end}}
		{{- if $cmd.Hidden}}
		Hidden: true,
		{{- end}}
		RunE: func(cmd *cobra.Command, args []string) error {
			return run{{pascalCase (cleanCommandName $cmd.Name)}}(cmd, args, handler)
		},
	}

	// Register persistent flags
	{{- range $cmd.PersistentFlags}}
	{{- if .Shorthand}}
	cmd.PersistentFlags().{{.GetCobraFlagMethodP}}("{{.Name}}", "{{.Shorthand}}", {{.GetDefaultValue}}, "{{escapeString .Description}}")
	{{- else}}
	cmd.PersistentFlags().{{.GetCobraFlagMethod}}("{{.Name}}", {{.GetDefaultValue}}, "{{escapeString .Description}}")
	{{- end}}
	{{- if .Required}}
	cmd.MarkPersistentFlagRequired("{{.Name}}")
	{{- end}}
	{{- end}}

	// Register flags
	{{- range $cmd.Flags}}
	{{- if .Shorthand}}
	cmd.Flags().{{.GetCobraFlagMethodP}}("{{.Name}}", "{{.Shorthand}}", {{.GetDefaultValue}}, "{{escapeString .Description}}")
	{{- else}}
	cmd.Flags().{{.GetCobraFlagMethod}}("{{.Name}}", {{.GetDefaultValue}}, "{{escapeString .Description}}")
	{{- end}}
	{{- if .Required}}
	cmd.MarkFlagRequired("{{.Name}}")
	{{- end}}
	{{- end}}

	return cmd
}

// run{{pascalCase (cleanCommandName $cmd.Name)}} handles argument and flag extraction
func run{{pascalCase (cleanCommandName $cmd.Name)}}(cmd *cobra.Command, args []string, handler {{$handlerName}}) error {
	{{- range $i, $arg := $cmd.Arguments}}
	{{camelCase $arg.Name}} := args[{{$i}}]
	{{- end}}
	
	{{- range $cmd.Flags}}
	{{camelCase .Name}}, _ := cmd.Flags().Get{{.GetCobraFlagMethod}}("{{.Name}}")
	{{- end}}
	
	{{- range $cmd.PersistentFlags}}
	{{camelCase .Name}}, _ := cmd.PersistentFlags().Get{{.GetCobraFlagMethod}}("{{.Name}}")
	{{- end}}

	{{- range $cmd.Flags}}
	{{- if .Enum}}
	// Validate enum for {{.Name}}
	{{camelCase .Name}}Valid := false
	for _, validValue := range []string{{"{"}}{{range $i, $val := .Enum}}{{if $i}}, {{end}}"{{$val}}"{{end}}{{"}"}} {
		if {{camelCase .Name}} == validValue {
			{{camelCase .Name}}Valid = true
			break
		}
	}
	if !{{camelCase .Name}}Valid {
		return fmt.Errorf("invalid {{.Name}}: %s (must be {{joinEnum .Enum}})", {{camelCase .Name}})
	}
	{{- end}}
	{{- end}}

	{{- range $cmd.PersistentFlags}}
	{{- if .Enum}}
	// Validate enum for {{.Name}}
	{{camelCase .Name}}Valid := false
	for _, validValue := range []string{{"{"}}{{range $i, $val := .Enum}}{{if $i}}, {{end}}"{{$val}}"{{end}}{{"}"}} {
		if {{camelCase .Name}} == validValue {
			{{camelCase .Name}}Valid = true
			break
		}
	}
	if !{{camelCase .Name}}Valid {
		return fmt.Errorf("invalid {{.Name}}: %s (must be {{joinEnum .Enum}})", {{camelCase .Name}})
	}
	{{- end}}
	{{- end}}

	// Create request
	req := &{{$structName}}{
		{{- if $cmd.Arguments}}
		Arguments: {{$structName}}Arguments{
			{{- range $cmd.Arguments}}
			{{pascalCase .Name}}: {{camelCase .Name}},
			{{- end}}
		},
		{{- end}}
		{{- if $cmd.Flags}}
		Flags: {{$structName}}Flags{
			{{- range $cmd.Flags}}
			{{pascalCase .Name}}: {{camelCase .Name}},
			{{- end}}
		},
		{{- end}}
		{{- if $cmd.PersistentFlags}}
		PersistentFlags: {{$structName}}PersistentFlags{
			{{- range $cmd.PersistentFlags}}
			{{pascalCase .Name}}: {{camelCase .Name}},
			{{- end}}
		},
		{{- end}}
		RawArguments: args,
	}

	// Call handler
	return handler(cmd, req)
}
`

// TemplateFunctions returns the template functions
func TemplateFunctions() template.FuncMap {
	return template.FuncMap{
		"pascalCase": pascalCase,
		"camelCase": func(s string) string {
			result := camelCase(s)
			// Handle Go reserved keywords
			switch result {
			case "package":
				return "pkg"
			case "func":
				return "fn"
			case "var":
				return "variable"
			case "type":
				return "typ"
			case "import":
				return "imp"
			case "interface":
				return "iface"
			default:
				return result
			}
		},
		"cleanCommandName": func(name string) string {
			// Remove everything from the first space or bracket
			parts := strings.Fields(name)
			if len(parts) > 0 {
				// Also remove any remaining brackets from the first part
				cleaned := strings.TrimSpace(parts[0])
				cleaned = strings.ReplaceAll(cleaned, "[", "")
				cleaned = strings.ReplaceAll(cleaned, "]", "")
				return cleaned
			}
			return name
		},
		"joinEnum": func(enum []string) string {
			if len(enum) <= 1 {
				return strings.Join(enum, "")
			}
			if len(enum) == 2 {
				return enum[0] + " or " + enum[1]
			}
			return strings.Join(enum[:len(enum)-1], ", ") + ", or " + enum[len(enum)-1]
		},
		"escapeString": func(s string) string {
			// Escape quotes in strings for Go code generation
			return strings.ReplaceAll(s, `"`, `\"`)
		},
	}
}
