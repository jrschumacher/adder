package adder

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestMixedGenerationScenario(t *testing.T) {
	// Test scenario: what if files were generated with different configurations?
	// This could happen if someone changed config and only regenerated some files
	
	tempDir, err := os.MkdirTemp("", "adder-mixed-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	inputDir := filepath.Join(tempDir, "docs", "man")
	outputDir := filepath.Join(tempDir, "cmd", "generated")

	// Create test files
	files := map[string]string{
		"dev/selectors/_index.md": `---
title: Dev Selectors
command:
  name: selectors
---
# Root command`,
		"dev/selectors/generate.md": `---
title: Generate
command:
  name: generate
---
# Generate command`,
	}

	for relPath, content := range files {
		fullPath := filepath.Join(inputDir, relPath)
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			t.Fatalf("Failed to create dir: %v", err)
		}
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to write file: %v", err)
		}
	}

	// Scenario 1: Generate with directory strategy first
	config1 := &Config{
		BinaryName:          "testapp",
		InputDir:            inputDir,
		OutputDir:           outputDir,
		Package:             "generated",
		GeneratedFileSuffix: "_generated.go",
		PackageStrategy:     "directory",
		IndexFormat:         "_index",
	}

	adder1 := New(config1)
	if err := adder1.Generate(); err != nil {
		t.Fatalf("Failed first generation: %v", err)
	}

	// Read what was generated
	checkGeneratedPackages := func(label string) {
		expectedDir := filepath.Join(outputDir, "dev", "selectors")
		entries, err := os.ReadDir(expectedDir)
		if err != nil {
			t.Logf("%s: No files generated yet", label)
			return
		}

		t.Logf("%s generated packages:", label)
		for _, entry := range entries {
			if !strings.HasSuffix(entry.Name(), "_generated.go") {
				continue
			}
			
			content, err := os.ReadFile(filepath.Join(expectedDir, entry.Name()))
			if err != nil {
				continue
			}
			
			lines := strings.Split(string(content), "\n")
			for _, line := range lines {
				if strings.HasPrefix(strings.TrimSpace(line), "package ") {
					pkg := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(line), "package"))
					t.Logf("  %s: package %s", entry.Name(), pkg)
					break
				}
			}
		}
	}

	checkGeneratedPackages("After directory strategy")

	// Now simulate what might happen if someone switches to single strategy
	// and only regenerates some files (or if there's a bug in file grouping)
	
	// Let's manually create a file with wrong package to simulate the bug
	wrongPackageFile := filepath.Join(outputDir, "dev", "selectors", "generate_generated.go")
	wrongContent := `// Code generated by adder. DO NOT EDIT.

package generated

import (
	"github.com/spf13/cobra"
)

// This simulates a file generated with wrong package name
type GenerateHandler func(cmd *cobra.Command, req *GenerateRequest) error

type GenerateRequest struct{}

func NewGenerateCommand(handler GenerateHandler) *cobra.Command {
	return &cobra.Command{Use: "generate"}
}
`
	
	if err := os.WriteFile(wrongPackageFile, []byte(wrongContent), 0644); err != nil {
		t.Fatalf("Failed to write wrong package file: %v", err)
	}

	checkGeneratedPackages("After simulating mixed packages")

	// This should show the inconsistency
	expectedDir := filepath.Join(outputDir, "dev", "selectors")
	entries, err := os.ReadDir(expectedDir)
	if err != nil {
		t.Fatalf("Failed to read final dir: %v", err)
	}

	packageCounts := make(map[string]int)
	for _, entry := range entries {
		if !strings.HasSuffix(entry.Name(), "_generated.go") {
			continue
		}
		
		content, err := os.ReadFile(filepath.Join(expectedDir, entry.Name()))
		if err != nil {
			continue
		}
		
		lines := strings.Split(string(content), "\n")
		for _, line := range lines {
			if strings.HasPrefix(strings.TrimSpace(line), "package ") {
				pkg := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(line), "package"))
				packageCounts[pkg]++
				break
			}
		}
	}

	if len(packageCounts) > 1 {
		t.Logf("✅ Successfully reproduced package inconsistency!")
		for pkg, count := range packageCounts {
			t.Logf("  package %s: %d files", pkg, count)
		}
		t.Logf("This demonstrates how mixed generation could cause the otdfctl issue")
	} else {
		t.Logf("No inconsistency found in this test")
	}
}

func TestSpecificOtdfctlPattern(t *testing.T) {
	// Test the exact pattern: _index has dev_selectors, others have generated
	// This suggests the _index file was generated with directory strategy
	// while other files were generated with single strategy (or vice versa)
	
	config := &Config{
		Package:         "generated",
		PackageStrategy: "directory",
		IndexFormat:     "_index",
	}

	// Test the specific files from otdfctl
	indexFile := "dev/selectors/_index.md"
	generateFile := "dev/selectors/generate.md" 
	testFile := "dev/selectors/test.md"

	indexPkg := config.GetPackageName(indexFile)
	generatePkg := config.GetPackageName(generateFile)
	testPkg := config.GetPackageName(testFile)

	t.Logf("Current adder behavior:")
	t.Logf("  %s -> package %s", indexFile, indexPkg)
	t.Logf("  %s -> package %s", generateFile, generatePkg)
	t.Logf("  %s -> package %s", testFile, testPkg)

	if indexPkg != generatePkg || indexPkg != testPkg {
		t.Errorf("❌ FOUND THE BUG! Different files in same directory get different packages!")
		t.Errorf("Expected all to have same package, but got:")
		t.Errorf("  Index: %s", indexPkg)
		t.Errorf("  Generate: %s", generatePkg)
		t.Errorf("  Test: %s", testPkg)
	} else {
		t.Logf("✅ All files get consistent package name: %s", indexPkg)
	}
}