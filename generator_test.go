package adder

import (
	"context"
	"os"
	"path/filepath"
	"testing"
)

func TestGenerator_Generate(t *testing.T) {
	// Create temporary directory for test output
	tempDir, err := os.MkdirTemp("", "adder-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create test input directory with test markdown
	inputDir := filepath.Join(tempDir, "input")
	if err := os.MkdirAll(inputDir, 0755); err != nil {
		t.Fatalf("Failed to create input dir: %v", err)
	}

	// Write test markdown file
	testMarkdown := `---
title: Test Command
command:
  name: test [arg]
  arguments:
    - name: arg
      description: Test argument
      required: true
      type: string
  flags:
    - name: verbose
      shorthand: v
      description: Verbose output
      type: bool
---

# Test Command

This is a test command for unit testing.`

	if err := os.WriteFile(filepath.Join(inputDir, "test.md"), []byte(testMarkdown), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Configure generator
	outputDir := filepath.Join(tempDir, "output")
	config := &Config{
		InputDir:   inputDir,
		OutputDir:  outputDir,
		Package:    "testpkg",
		GeneratedFileSuffix: "_generated.go",
	}

	generator := New(config)

	// Test generation
	ctx := context.Background()
	if err := generator.GenerateWithContext(ctx); err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify output file was created
	expectedFile := filepath.Join(outputDir, "test_generated.go")
	if _, err := os.Stat(expectedFile); os.IsNotExist(err) {
		t.Errorf("Expected output file %s was not created", expectedFile)
	}

	// Read and verify content
	content, err := os.ReadFile(expectedFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	contentStr := string(content)

	// Check for expected content
	expectedStrings := []string{
		"package testpkg",
		"// Code generated by adder. DO NOT EDIT.",
		"type TestRequestArguments struct",
		"type TestRequestFlags struct",
		"type TestRequest struct",
		"type TestHandler interface",
		"func NewTestCommand",
		"HandleTest(cmd *cobra.Command, req *TestRequest) error",
	}

	for _, expected := range expectedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Generated content missing expected string: %q", expected)
		}
	}
}

func TestGenerator_Validate(t *testing.T) {
	tests := []struct {
		name      string
		markdown  string
		wantError bool
	}{
		{
			name: "valid command",
			markdown: `---
title: Valid Command
command:
  name: valid
  flags:
    - name: flag
      type: string
---`,
			wantError: false,
		},
		{
			name: "enum on non-string flag",
			markdown: `---
title: Invalid Command
command:
  name: invalid
  flags:
    - name: flag
      type: int
      enum:
        - 1
        - 2
---`,
			wantError: true,
		},
		{
			name: "duplicate field names",
			markdown: `---
title: Duplicate Fields
command:
  name: duplicate
  arguments:
    - name: label
      type: string
  flags:
    - name: label
      type: string
---`,
			wantError: true,
		},
		{
			name: "arguments as array of strings",
			markdown: `---
title: String Array Arguments
command:
  name: string-args
  arguments:
    - file
    - output
---`,
			wantError: false,
		},
		{
			name: "mixed argument formats (should fail)",
			markdown: `---
title: Mixed Arguments
command:
  name: mixed-args
  arguments:
    - file
    - name: detailed
      type: string
---`,
			wantError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temporary directory
			tempDir, err := os.MkdirTemp("", "adder-validate-test-*")
			if err != nil {
				t.Fatalf("Failed to create temp dir: %v", err)
			}
			defer func() { _ = os.RemoveAll(tempDir) }()

			// Write test file
			inputDir := filepath.Join(tempDir, "input")
			if err := os.MkdirAll(inputDir, 0755); err != nil {
				t.Fatalf("Failed to create input dir: %v", err)
			}

			if err := os.WriteFile(filepath.Join(inputDir, "test.md"), []byte(tt.markdown), 0644); err != nil {
				t.Fatalf("Failed to write test file: %v", err)
			}

			// Create generator
			config := &Config{
				InputDir:   inputDir,
				OutputDir:  filepath.Join(tempDir, "output"),
				Package:    "testpkg",
				GeneratedFileSuffix: "_generated.go",
			}

			generator := New(config)

			// Test validation
			err = generator.Validate()

			if tt.wantError && err == nil {
				t.Errorf("Expected validation error but got none")
			}
			if !tt.wantError && err != nil {
				t.Errorf("Unexpected validation error: %v", err)
			}
		})
	}
}

func TestGenerator_StringEscaping(t *testing.T) {
	// Create temporary directory for test output
	tempDir, err := os.MkdirTemp("", "adder-escape-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create test input directory with markdown containing quotes
	inputDir := filepath.Join(tempDir, "input")
	if err := os.MkdirAll(inputDir, 0755); err != nil {
		t.Fatalf("Failed to create input dir: %v", err)
	}

	// Write test markdown file with quoted descriptions
	testMarkdown := `---
title: String Escape Test
command:
  name: escape-test
  flags:
    - name: example
      description: 'Use format "key=value" for this flag'
      type: string
    - name: pattern
      description: 'Example: pattern="*.go" or pattern="test_*"'
      type: string
---

# String Escape Test

Test command with quotes in descriptions.`

	if err := os.WriteFile(filepath.Join(inputDir, "escape.md"), []byte(testMarkdown), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Configure generator
	outputDir := filepath.Join(tempDir, "output")
	config := &Config{
		InputDir:   inputDir,
		OutputDir:  outputDir,
		Package:    "testpkg",
		GeneratedFileSuffix: "_generated.go",
	}

	generator := NewGenerator(config)

	// Test generation
	ctx := context.Background()
	inputFS := os.DirFS(inputDir)
	if err := generator.Generate(ctx, inputFS); err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify output file was created
	expectedFile := filepath.Join(outputDir, "escape_generated.go")
	if _, err := os.Stat(expectedFile); os.IsNotExist(err) {
		t.Errorf("Expected output file %s was not created", expectedFile)
	}

	// Read and verify content has escaped quotes
	content, err := os.ReadFile(expectedFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	contentStr := string(content)

	// Check that quotes are properly escaped in comments and strings
	expectedEscapedStrings := []string{
		`// Use format \"key=value\" for this flag`,
		`// Example: pattern=\"*.go\" or pattern=\"test_*\"`,
		`"Use format \"key=value\" for this flag"`,
		`"Example: pattern=\"*.go\" or pattern=\"test_*\""`,
	}

	for _, expected := range expectedEscapedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Generated content missing properly escaped string: %q", expected)
		}
	}

	// Check that unescaped quotes don't exist (would cause compilation errors)
	forbiddenStrings := []string{
		`"key=value"`,  // in comment
		`"*.go"`,       // in comment  
		`"test_*"`,     // in comment
	}

	for _, forbidden := range forbiddenStrings {
		if contains(contentStr, forbidden) {
			t.Errorf("Generated content contains unescaped quotes that would cause compilation errors: %q", forbidden)
		}
	}
}

func TestGenerator_GetStats(t *testing.T) {
	generator := &Generator{
		commands: []*Command{
			{
				Name:      "cmd1",
				Arguments: []Argument{{Name: "arg1"}},
				Flags:     []Flag{{Name: "flag1"}, {Name: "flag2"}},
			},
			{
				Name:      "cmd2",
				Arguments: []Argument{{Name: "arg2"}, {Name: "arg3"}},
				Flags:     []Flag{{Name: "flag3"}},
			},
		},
	}

	stats := generator.GetStats()

	expectedStats := map[string]int{
		"total_commands":  2,
		"total_arguments": 3,
		"total_flags":     3,
	}

	for key, expected := range expectedStats {
		if stats[key] != expected {
			t.Errorf("GetStats()[%q] = %d, want %d", key, stats[key], expected)
		}
	}
}

func TestParser_ArgumentFormats(t *testing.T) {
	tests := []struct {
		name      string
		markdown  string
		wantArgs  []Argument
		wantError bool
	}{
		{
			name: "object format arguments",
			markdown: `---
title: Object Format Test
command:
  name: object-test
  arguments:
    - name: file
      description: Input file
      required: true
      type: string
    - name: output
      description: Output file
      required: false
      type: string
---`,
			wantArgs: []Argument{
				{Name: "file", Description: "Input file", Required: true, Type: "string"},
				{Name: "output", Description: "Output file", Required: false, Type: "string"},
			},
			wantError: false,
		},
		{
			name: "string array format arguments",
			markdown: `---
title: String Array Test
command:
  name: string-test
  arguments:
    - file
    - output
    - pattern
---`,
			wantArgs: []Argument{
				{Name: "file", Description: "", Required: true, Type: "string"},
				{Name: "output", Description: "", Required: true, Type: "string"},
				{Name: "pattern", Description: "", Required: true, Type: "string"},
			},
			wantError: false,
		},
		{
			name: "empty arguments",
			markdown: `---
title: No Arguments Test
command:
  name: no-args
  arguments: []
---`,
			wantArgs:  []Argument{},
			wantError: false,
		},
		{
			name: "mixed formats (should fail)",
			markdown: `---
title: Mixed Format Test
command:
  name: mixed-test
  arguments:
    - file
    - name: detailed
      type: string
---`,
			wantArgs:  nil,
			wantError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			parser := NewParser(DefaultConfig())
			cmd, err := parser.ParseContent(tt.markdown, "test.md")

			if tt.wantError {
				if err == nil {
					t.Errorf("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if cmd == nil {
				t.Fatalf("Expected command but got nil")
			}

			if len(cmd.Arguments) != len(tt.wantArgs) {
				t.Errorf("Expected %d arguments, got %d", len(tt.wantArgs), len(cmd.Arguments))
				return
			}

			for i, expected := range tt.wantArgs {
				actual := cmd.Arguments[i]
				if actual.Name != expected.Name {
					t.Errorf("Argument %d: expected name %q, got %q", i, expected.Name, actual.Name)
				}
				if actual.Description != expected.Description {
					t.Errorf("Argument %d: expected description %q, got %q", i, expected.Description, actual.Description)
				}
				if actual.Required != expected.Required {
					t.Errorf("Argument %d: expected required %v, got %v", i, expected.Required, actual.Required)
				}
				if actual.Type != expected.Type {
					t.Errorf("Argument %d: expected type %q, got %q", i, expected.Type, actual.Type)
				}
			}
		})
	}
}

// Helper function to check if string contains substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(substr) <= len(s) && s[:len(substr)] == substr) ||
		contains(s[1:], substr))
}
