package adder

import (
	"context"
	"os"
	"path/filepath"
	"testing"
)

func TestGenerator_Generate(t *testing.T) {
	// Create temporary directory for test output
	tempDir, err := os.MkdirTemp("", "adder-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create test input directory with test markdown
	inputDir := filepath.Join(tempDir, "input")
	if err := os.MkdirAll(inputDir, 0755); err != nil {
		t.Fatalf("Failed to create input dir: %v", err)
	}

	// Write test markdown file
	testMarkdown := `---
title: Test Command
command:
  name: test [arg]
  arguments:
    - name: arg
      description: Test argument
      required: true
      type: string
  flags:
    - name: verbose
      shorthand: v
      description: Verbose output
      type: bool
---

# Test Command

This is a test command for unit testing.`

	if err := os.WriteFile(filepath.Join(inputDir, "test.md"), []byte(testMarkdown), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Configure generator
	outputDir := filepath.Join(tempDir, "output")
	config := &Config{
		InputDir:   inputDir,
		OutputDir:  outputDir,
		Package:    "testpkg",
		FileSuffix: "_generated.go",
	}

	generator := New(config)

	// Test generation
	ctx := context.Background()
	if err := generator.GenerateWithContext(ctx); err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify output file was created
	expectedFile := filepath.Join(outputDir, "test_generated.go")
	if _, err := os.Stat(expectedFile); os.IsNotExist(err) {
		t.Errorf("Expected output file %s was not created", expectedFile)
	}

	// Read and verify content
	content, err := os.ReadFile(expectedFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	contentStr := string(content)

	// Check for expected content
	expectedStrings := []string{
		"package testpkg",
		"// Code generated by adder. DO NOT EDIT.",
		"type TestRequestArguments struct",
		"type TestRequestFlags struct",
		"type TestRequest struct",
		"type TestHandler interface",
		"func NewTestCommand",
		"HandleTest(cmd *cobra.Command, req *TestRequest) error",
	}

	for _, expected := range expectedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Generated content missing expected string: %q", expected)
		}
	}
}

func TestGenerator_Validate(t *testing.T) {
	tests := []struct {
		name      string
		markdown  string
		wantError bool
	}{
		{
			name: "valid command",
			markdown: `---
title: Valid Command
command:
  name: valid
  flags:
    - name: flag
      type: string
---`,
			wantError: false,
		},
		{
			name: "enum on non-string flag",
			markdown: `---
title: Invalid Command
command:
  name: invalid
  flags:
    - name: flag
      type: int
      enum:
        - 1
        - 2
---`,
			wantError: true,
		},
		{
			name: "duplicate field names",
			markdown: `---
title: Duplicate Fields
command:
  name: duplicate
  arguments:
    - name: label
      type: string
  flags:
    - name: label
      type: string
---`,
			wantError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temporary directory
			tempDir, err := os.MkdirTemp("", "adder-validate-test-*")
			if err != nil {
				t.Fatalf("Failed to create temp dir: %v", err)
			}
			defer func() { _ = os.RemoveAll(tempDir) }()

			// Write test file
			inputDir := filepath.Join(tempDir, "input")
			if err := os.MkdirAll(inputDir, 0755); err != nil {
				t.Fatalf("Failed to create input dir: %v", err)
			}

			if err := os.WriteFile(filepath.Join(inputDir, "test.md"), []byte(tt.markdown), 0644); err != nil {
				t.Fatalf("Failed to write test file: %v", err)
			}

			// Create generator
			config := &Config{
				InputDir:   inputDir,
				OutputDir:  filepath.Join(tempDir, "output"),
				Package:    "testpkg",
				FileSuffix: "_generated.go",
			}

			generator := New(config)

			// Test validation
			err = generator.Validate()

			if tt.wantError && err == nil {
				t.Errorf("Expected validation error but got none")
			}
			if !tt.wantError && err != nil {
				t.Errorf("Unexpected validation error: %v", err)
			}
		})
	}
}

func TestGenerator_StringEscaping(t *testing.T) {
	// Create temporary directory for test output
	tempDir, err := os.MkdirTemp("", "adder-escape-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create test input directory with markdown containing quotes
	inputDir := filepath.Join(tempDir, "input")
	if err := os.MkdirAll(inputDir, 0755); err != nil {
		t.Fatalf("Failed to create input dir: %v", err)
	}

	// Write test markdown file with quoted descriptions
	testMarkdown := `---
title: String Escape Test
command:
  name: escape-test
  flags:
    - name: example
      description: 'Use format "key=value" for this flag'
      type: string
    - name: pattern
      description: 'Example: pattern="*.go" or pattern="test_*"'
      type: string
---

# String Escape Test

Test command with quotes in descriptions.`

	if err := os.WriteFile(filepath.Join(inputDir, "escape.md"), []byte(testMarkdown), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Configure generator
	outputDir := filepath.Join(tempDir, "output")
	config := &Config{
		InputDir:   inputDir,
		OutputDir:  outputDir,
		Package:    "testpkg",
		FileSuffix: "_generated.go",
	}

	generator := NewGenerator(config)

	// Test generation
	ctx := context.Background()
	inputFS := os.DirFS(inputDir)
	if err := generator.Generate(ctx, inputFS); err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify output file was created
	expectedFile := filepath.Join(outputDir, "escape_generated.go")
	if _, err := os.Stat(expectedFile); os.IsNotExist(err) {
		t.Errorf("Expected output file %s was not created", expectedFile)
	}

	// Read and verify content has escaped quotes
	content, err := os.ReadFile(expectedFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	contentStr := string(content)

	// Check that quotes are properly escaped in comments and strings
	expectedEscapedStrings := []string{
		`// Use format \"key=value\" for this flag`,
		`// Example: pattern=\"*.go\" or pattern=\"test_*\"`,
		`"Use format \"key=value\" for this flag"`,
		`"Example: pattern=\"*.go\" or pattern=\"test_*\""`,
	}

	for _, expected := range expectedEscapedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Generated content missing properly escaped string: %q", expected)
		}
	}

	// Check that unescaped quotes don't exist (would cause compilation errors)
	forbiddenStrings := []string{
		`"key=value"`,  // in comment
		`"*.go"`,       // in comment  
		`"test_*"`,     // in comment
	}

	for _, forbidden := range forbiddenStrings {
		if contains(contentStr, forbidden) {
			t.Errorf("Generated content contains unescaped quotes that would cause compilation errors: %q", forbidden)
		}
	}
}

func TestGenerator_GetStats(t *testing.T) {
	generator := &Generator{
		commands: []*Command{
			{
				Name:      "cmd1",
				Arguments: []Argument{{Name: "arg1"}},
				Flags:     []Flag{{Name: "flag1"}, {Name: "flag2"}},
			},
			{
				Name:      "cmd2",
				Arguments: []Argument{{Name: "arg2"}, {Name: "arg3"}},
				Flags:     []Flag{{Name: "flag3"}},
			},
		},
	}

	stats := generator.GetStats()

	expectedStats := map[string]int{
		"total_commands":  2,
		"total_arguments": 3,
		"total_flags":     3,
	}

	for key, expected := range expectedStats {
		if stats[key] != expected {
			t.Errorf("GetStats()[%q] = %d, want %d", key, stats[key], expected)
		}
	}
}

// Helper function to check if string contains substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(substr) <= len(s) && s[:len(substr)] == substr) ||
		contains(s[1:], substr))
}
